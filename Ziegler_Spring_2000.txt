Go2.m:
% FEC CODE RECOGNITION MAIN PROGRAM

% Select test code to identify
%FileName = 'Uncoded'; % control test case
%%% Binary codes
%FileName = 'Hamming3';
%FileName = 'Hamming4';
%FileName = 'Golay23-1';
%FileName = 'Golay23-2';
%FileName = 'Crc7-4-1';
%FileName = 'Bch63-45-3';
%FileName = 'rm16-5-3';
%%% 4-ary codes
%FileName = 'Bch21-15-1-4';
%FileName = 'Bch21-12-2-4';
%%% 16-ary codes
%FileName = 'Bch85-73-3-16';
%%% 64-ary codes
%FileName = 'Rs63-57-3';
%%% 256-ary codes
%FileName = 'Rs255-245-5';
%%% Rate 1/n convolutional codes
%FileName = 'ConvR1-2_K3';
%FileName = 'ConvR1-2_K4';
%FileName = 'ConvR1-2_K5';
%FileName = 'ConvR1-2_K6';
%FileName = 'ConvR1-2_K7';
%FileName = 'ConvR1-2_K8';
%FileName = 'ConvR1-2_K9';
%FileName = 'ConvR1-2_K9b';
%FileName = 'ConvR1-2_K14';
%FileName = 'ConvR1-3_K3';
%FileName = 'ConvR1-3_K4b';
%FileName = 'ConvR1-3_K8';
%FileName = 'ConvR1-3_K14';
%FileName = 'ConvR1-4_K3';
%FileName = 'ConvR1-4_K7';
%FileName = 'ConvR1-4_K14';
%FileName = 'ConvR2-3_K3_M4';
%FileName = 'ConvR2-3_K6_M10';
FileName = 'ConvR3-4_K4_M9';

% Search for rate k/n convolutional codes via RREF in GF(2), including
% constraint length
[ConvCWLenEst,InputLenEst,ConstraintLenEst] = FindMem6(FileName,3,4,14);

if (ConvCWLenEst > 0) & (ConstraintLenEst > 0)
   if (InputLenEst == 1)
      % Search for generator polynomials given K for rate 1/n
      % convolutional codes
      G = FindGenPolys(FileName,ConvCWLenEst,ConstraintLenEst);
   else
      % Generator polynomial search for k>1 convolutional codes is too
      % complex
      G = [];
   end

   fprintf('\n----------------\n')
   fprintf('Identified (%d,%d,%d) convolutional code\n',...
               ConvCWLenEst,InputLenEst,ConstraintLenEst);
   if ~isempty(G)
      fprintf('Order-%d generator polynomials (in octal):\n',...
               ConstraintLenEst-1);
      G
   end
   return
end

% Generate Galois Field vector representations for GF(2^3) to GF(2^13)
if ~exist('vectors8_m1')
   ReadFields
end

WordCount = 30;
warning off         % disable log of zero warning message

% Estimate block code params (n,k,q) via RREF in GF(q)
[RateEst,CWLenEst,InputLenEst,AlphabetSizeEst] = ...
   EstRate3(FileName,7,255,8)

if RateEst<1

% Search for cyclic codes via GFFT root search in extension fields
[ExtFieldEst,ExtRoots,CWLenEst2] = ...
   FindRoots(FileName,WordCount,AlphabetSizeEst,CWLenEst)
warning on

if ~isempty(ExtFieldEst)
   if CWLenEst ~= CWLenEst2
      disp 'Error: conflicting code word lengths'
      dbcont   % exit
   end
end

if length(ExtRoots)>0
   disp 'Found cyclic block code'

  % Convert roots to base field by multiplying by (q^m-1)/n




ExtRoots = ExtRoots-1;
BaseRoots = ExtRoots*(ExtFieldEst-1)/CWLenEst

% Rebuild generator polynomial by convolving all roots together:
% g(x) = (x+alpha^r1)*(x+alpha^r2)...*(x+alpha^ri)
g = PolyGFx(BaseRoots,CWLenEst,AlphabetSizeEst,ExtFieldEst,1)

redundancy = length(g) - 1
InputLenEst2 = CWLenEst - redundancy
if InputLenEst ~= InputLenEst2
   disp 'Error: conflicting input word lengths'
   dbcont   % exit
end

[ConsecRoots,t] = FindConsecRoots(ExtRoots)
dmin = EstMinDist(FileName,CWLenEst,AlphabetSizeEst,InputLenEst*2)
if t>0
   CodeType = 'BCH'
   if (CWLenEst==AlphabetSizeEst-1 & ExtFieldEst==AlphabetSizeEst)
      CodeType = 'Reed-Solomon'
   end
   if dmin < 2*t+1
      disp 'Error: invalid minimum distance (dmin < 2*t+1)'
      dbcont   % exit
   else
      disp 'Check: dmin > 2*t'
   end
   if rem(ExtFieldEst-1,CWLenEst) == 0
      disp 'Check: q^m-1 | n'
   else
      disp 'Error: invalid BCH code (n != q^m-1)'
      dbcont   % exit
   end
else
   CodeType = 'CRC or perfect cyclic block'
   t = floor((dmin-1)/2)

  redundancy2 = EstRedundancy(CWLenEst,AlphabetSizeEst,t)
  if redundancy == redundancy2
     disp 'Assume perfect block code'
     CodeType = 'perfect block'
     if InputLenEst == 1
        if t == (CWLenEst-1)/2
           CodeType = 'binary repetition'
        else
           disp 'Error: invalid repetition code (t != (n-1)/2)'
           dbcont   % exit
        end
     elseif (InputLenEst==12 & CWLenEst==23)
        if t == 3
           CodeType = 'binary Golay'
        else
           disp 'Error: invalid Golay code (t != 3)'
           dbcont   % exit
        end
     elseif CWLenEst == ExtFieldEst-1




           if t == 1
              CodeType = 'binary Hamming'
           else
              disp 'Error: invalid Hamming code (t != 1)'
              dbcont   % exit
           end
        else
           disp 'Error: invalid perfect code (no match)'
           dbcont   % exit
        end

      else
         disp 'Assume CRC block code'
         CodeType = 'CRC block';
      end
   end
else
   disp 'Assume non-cyclic block code'
   CodeType = 'non-cyclic block';
   dmin = EstMinDist(FileName,CWLenEst,AlphabetSizeEst,InputLenEst*2)
   t = floor((dmin-1)/2)
   redundancy = CWLenEst - InputLenEst;
   redundancy2 = EstRedundancy(CWLenEst,AlphabetSizeEst,t)
   if (redundancy==redundancy2 & t==1)
      CodeType = 'binary Hamming';
   end
end

fprintf('\n----------------\n')
fprintf('Identified code:\n')
fprintf('(%d,%d) %d-ary %d-error correcting %s code\n',...
         CWLenEst,InputLenEst,AlphabetSizeEst,t,CodeType);
if ~isempty(ExtFieldEst)
   fprintf('Roots in GF(%d) as powers of alpha:\n',ExtFieldEst);
   BaseRoots
   if max(g)<2
      fprintf('Order-%d binary generator polynomial (in octal):\n', ...
               redundancy);
      g = oct2gen(g,[1,1,redundancy])
   else
      fprintf('Order-%d generator polynomial:\n',redundancy);
      g
   end
end

end

FindMem6.m:
function [ConvCWLenEst,InputLenEst,ConstraintLenEst] = ...
         FindMem6(FileName,kmax,nmax,Kmax)

% RREF TECHNIQUE IN GF(2) ADAPTED TO CONVOLUTIONAL CODES

% Increase max memory length to ensure valid test up to Kmax;




% this avoids false detection of block codes
margin = 4;
Kmax = Kmax+margin;
InputLenEst = 0;
ConvCWLenEst = 0;
ConstraintLenEst = 0;
compr = ones(nmax,Kmax);
ConsecCompr = 0;


for n=2:nmax
   n
   k = 1;
   TH = (k+1)/n;
   ConstraintLenEst = 0;
   PrevRate = 1;
   PrevK = 2;
   PrevDelta = 0;
   FirstCompr = 0;

  for K=3:Kmax
     nK = n*K;
     WordCount = 2*nK;
     EncodedBitCount = nK*WordCount;
     s = sprintf('%s.fec',FileName);
     CodedFile = fopen(s,'r');

     [r,WordsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
     if(WordsRead ~= EncodedBitCount)
        disp 'Error reading file'
        WordsRead
     end

     r2 = reshape(r,nK,WordCount)';
     %[G2,nK] = RrefGF2(r2);
     [G2,kK] = RrefGF2c(r2);    % MEX C-code implementation

     rate = kK/nK;
     compr(n,K) = rate;   % DEBUG: bitwise RREF compression
     delta = nK-kK;
     delta2 = delta - PrevDelta;
     PrevDelta = delta;


     if FirstCompr
        k = n-delta2;
        TH = (k+1)/n;
        if TH > 1
           TH = 1;
        end
     end

     if rate < 1
        fprintf('Rate = %d/%d = %f, n = %d, K = %d, delta = %d, ...
                 delta2 = %d\n',kK,nK,rate,n,K,delta,delta2)
        FirstCompr = 1;




         if (rate < PrevRate) & (K == PrevK+1)
            PrevRate = rate;
            PrevK = K;
            ConvCWLenEst = n;
            ConsecCompr = ConsecCompr+1;
            if (rate < TH) & (ConstraintLenEst < 1)
               InputLenEst = k
               % Set K at first rate to drop below the threshold
               ConstraintLenEst = ((K-1)/k)+1;
               fprintf('(Rate = %f) < (threshold = %f) at ...
                        K = %d\n',rate,TH,K)
            end
         else
            % Invalidate this trial since its rate is not
            % monotonically decreasing
            ConvCWLenEst = 0;
            InputLenEst = 0;
            break
         end
      elseif ~FirstCompr
         PrevK = K;
      else
         % Invalidate this trial since its rate is not
         % monotonically decreasing
         ConvCWLenEst = 0;
         InputLenEst = 0;
         break
      end

     fclose(CodedFile);
  end

  if (ConvCWLenEst > 0) & (InputLenEst > 0) & (ConsecCompr >= margin)
     break
  end

end




% Repeat search for K if k > 1, given (n,k) and appropriate threshold,
% to revise estimate of constraint length
if (ConvCWLenEst > 0) & (InputLenEst > 1)
   TH = (k+1)/n;
   for K=3:Kmax
      nK = n*K;
      WordCount = 2*nK;
      EncodedBitCount = nK*WordCount;
      s = sprintf('%s.fec',FileName);
      CodedFile = fopen(s,'r');
      [r,WordsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
      if(WordsRead ~= EncodedBitCount)
         disp 'Error reading file'
         WordsRead
      end




      r2 = reshape(r,nK,WordCount)';
      [G2,kK] = RrefGF2c(r2);    % MEX C-code implementation
      rate = kK/nK;

      if (rate < TH)
         % Set K at first rate to drop below the threshold
         ConstraintLenEst = ((K-1)/k)+1;
         fprintf('(Rate = %f) < (threshold = %f) at K2 = %d; ...
                  K = %d\n',rate,TH,K,ConstraintLenEst)
         fclose(CodedFile);
         break
      end
      fclose(CodedFile);
   end
end


if (ConvCWLenEst > 0) & (ConstraintLenEst > 0)
   fprintf('Found convolutional code: n = %d, k = %d, K = %d\n', ...
            ConvCWLenEst,InputLenEst,ConstraintLenEst)
else
   disp 'CONVOLUTIONAL CODE NOT FOUND'
end


if 0
figure
Ki = [3:Kmax];
plot(Ki,compr(2,Ki),'b*-')
hold
plot(Ki,compr(3,Ki),'ro-')
plot(Ki,compr(4,Ki),'gd-')
xlabel('Constraint Length (K)')
ylabel('RREF Compression')
legend('Rate 1/2','Rate 1/3','Rate 1/4',0)
end


FindGenPolys.m:
function [G2] = FindGenPolys(FileName,n,K)

% FIND CONVOLUTIONAL CODE GENERATOR POLYNOMIALS VIA DATA CANCELLATION

WordCount = 20*K;
N = WordCount+(n-1)*(K-1);

EncodedBitCount = n*WordCount;
s = sprintf('%s.fec',FileName);
CodedFile = fopen(s,'r');

[r,WordsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
if(WordsRead ~= EncodedBitCount)
   disp 'Error reading file'




   WordsRead
end

r2 = reshape(r,n,WordCount);

perm = prod([1:n])      % n! = # of possible orderings of gi(x)
PermLUT = perms(1:n);         % table of index permutations for gi(x)
%PermLUT = fliplr(perms(1:n)) % table of index permutations for gi(x)
comb = 2^(n*K)          % # of tap combinations across all polynomials
MaxComb = 1e6;          % maximum # of tap combinations to search


% Search based on best known polynomials first
if n==2

    switch K
       case 3,
          G = oct2gen([5;7]);
       case 4,
          G = oct2gen([64;74]);
%         G = oct2gen([74;64]);
       case 5,
          G = oct2gen([46;72]);
       case 6,
          G = oct2gen([65;57]);
       case 7,
          G = oct2gen([554;744]);
       case 8,
          G = oct2gen([712;476]);
       case 9,
          G = oct2gen([561;753]);
       case 10,
          G = oct2gen([4734;6624]);
       case 11,
          G = oct2gen([4672;7542]);
       case 12,
          G = oct2gen([4335;5723]);
       case 13,
          G = oct2gen([42554;77304]);
       case 14,
          G = oct2gen([43572;56246]);
    end

    % Try possible orderings until a winner is found
    fprintf('Searching for optimal generators\n')
    for i=1:perm
       a1 = G(i,:);
       a2 = G(perm+1-i,:);
       P1 = gfconv(a1,r2(1,:));
       P1 = [P1 zeros(1,N-length(P1))];
       P2 = gfconv(a2,r2(2,:));
       P2 = [P2 zeros(1,N-length(P2))];
       S = mod(P1+P2,2);
       S = S(1:WordCount);
       if sum(S)==0
          fprintf('Found generators at trial %d:\n',i)




          G2 = oct2gen([a2;a1],[1,n,K-1])
          break
       end
    end

    if (sum(S)~=0) & (comb<MaxComb)
       % Try all generator tap combinations, except when any gi(x)=0
       fprintf('Searching suboptimal generators\n')
       mask = 2^K-1;
       imin = 2^K;
       j = 0;
       for i=imin:comb-1
          g1o = bitand(bitshift(i,-K),mask);
          g2o = bitand(i,mask);
          if (g1o>0) & (g2o>0)
             j = j+1;
             a1 = de2bi(g1o,K);
             a2 = de2bi(g2o,K);
             P1 = gfconv(a1,r2(1,:));
             P1 = [P1 zeros(1,N-length(P1))];
             P2 = gfconv(a2,r2(2,:));
             P2 = [P2 zeros(1,N-length(P2))];
             S = mod(P1+P2,2);
             S = S(1:WordCount);
             if sum(S)==0
                fprintf('Found generators at i=%d (trial %d):\n',i,j)
                G2 = oct2gen([a2;a1],[1,n,K-1])
                break
             end
          end
       end
    end

    if sum(S)~=0
       fprintf('No generators found\n')
    end

elseif n==3

    switch K
       case 3,
          G = oct2gen([5;7;7]);
%          G = oct2gen([7;5;7]);
%          G = oct2gen([7;7;5]);
       case 4,
          G = oct2gen([54;64;74]);
       case 5,
          G = oct2gen([52;66;76]);
       case 6,
          G = oct2gen([47;53;75]);
       case 7,
          G = oct2gen([554;624;764]);
       case 8,
          G = oct2gen([452;662;756]);
       case 9,
          G = oct2gen([557;663;711]);




       case   10,
          G   = oct2gen([4474;5724;7154]);
       case   11,
          G   = oct2gen([4726;5562;6372]);
       case   12,
          G   = oct2gen([4767;5723;6265]);
       case   13,
          G   = oct2gen([42554;43364;77304]);
       case   14,
          G   = oct2gen([43512;73542;76266]);
%         G   = oct2gen([73542;43512;76266]);
    end

    % Try possible orderings until a winner is found
    fprintf('Searching for optimal generators\n')
    for i=1:perm
       g1 = G(PermLUT(i,1),:);
       g2 = G(PermLUT(i,2),:);
       g3 = G(PermLUT(i,3),:);
       a1 = gfconv(g2,g3);
       a2 = gfconv(g1,g3);
       a3 = gfconv(g1,g2);
       P1 = gfconv(a1,r2(1,:));
       P1 = [P1 zeros(1,N-length(P1))];
       P2 = gfconv(a2,r2(2,:));
       P2 = [P2 zeros(1,N-length(P2))];
       P3 = gfconv(a3,r2(3,:));
       P3 = [P3 zeros(1,N-length(P3))];
       S = mod(P1+P2+P3,3);
       S = S(1:WordCount);
       if sum(S)==0
          fprintf('Found generators at trial %d:\n',i)
          G2 = oct2gen([g1;g2;g3],[1,n,K-1])
          break
       end
    end

    if (sum(S)~=0) & (comb<MaxComb)
       % Try all generator tap combinations, except when any gi(x)=0
       fprintf('Searching suboptimal generators\n')
       mask = 2^K-1;
       imin = 2^((n-1)*K);
       j = 0;
       for i=imin:comb-1
          g1o = bitand(bitshift(i,-2*K),mask);
          g2o = bitand(bitshift(i,-K),mask);
          g3o = bitand(i,mask);
          if (g1o>0) & (g2o>0) & (g3o>0)
             j = j+1;
             g1 = de2bi(g1o,K);
             g2 = de2bi(g2o,K);
             g3 = de2bi(g3o,K);
             a1 = gfconv(g2,g3);
             a2 = gfconv(g1,g3);
             a3 = gfconv(g1,g2);
             P1 = gfconv(a1,r2(1,:));




             P1 = [P1 zeros(1,N-length(P1))];
             P2 = gfconv(a2,r2(2,:));
             P2 = [P2 zeros(1,N-length(P2))];
             P3 = gfconv(a3,r2(3,:));
             P3 = [P3 zeros(1,N-length(P3))];
             S = mod(P1+P2+P3,3);
             S = S(1:WordCount);
             if sum(S)==0
                fprintf('Found generators at i=%d (trial %d):\n',i,j)
                G2 = oct2gen([g1;g2;g3],[1,n,K-1])
                break
             end
          end
       end
    end

    if sum(S)~=0
       fprintf('No generators found\n')
    end

elseif n==4

    switch K
       case 3,
          G = oct2gen([5;7;7;7]);
%          G = oct2gen([7;7;5;7]);
       case 4,
          G = oct2gen([54;64;64;74]);
       case 5,
          G = oct2gen([52;56;66;76]);
       case 6,
          G = oct2gen([53;67;71;75]);
       case 7,
          G = oct2gen([564;564;634;714]);
%          G = oct2gen([564;634;714;564]);
       case 8,
          G = oct2gen([472;572;626;736]);
       case 9,
          G = oct2gen([463;535;733;745]);
       case 10,
          G = oct2gen([4474;5724;7154;7254]);
       case 11,
          G = oct2gen([4656;4726;5562;6372]);
       case 12,
          G = oct2gen([4767;5723;6265;7455]);
       case 13,
          G = oct2gen([44624;52374;66754;73534]);
       case 14,
          G = oct2gen([42226;46372;73256;73276]);
    end

    % Try possible orderings until a winner is found
    fprintf('Searching for optimal generators\n')
    for i=1:perm
       g1 = G(PermLUT(i,1),:);
       g2 = G(PermLUT(i,2),:);




   g3 = G(PermLUT(i,3),:);
   g4 = G(PermLUT(i,4),:);
   a12 = gfconv(g1,g2);
   a13 = gfconv(g1,g3);
   a23 = gfconv(g2,g3);
   a1 = gfconv(a23,g4);
   a2 = gfconv(a13,g4);
   a3 = gfconv(a12,g4);
   a4 = gfconv(a12,g3);
   P1 = gfconv(a1,r2(1,:));
   P1 = [P1 zeros(1,N-length(P1))];
   P2 = gfconv(a2,r2(2,:));
   P2 = [P2 zeros(1,N-length(P2))];
   P3 = gfconv(a3,r2(3,:));
   P3 = [P3 zeros(1,N-length(P3))];
   P4 = gfconv(a4,r2(4,:));
   P4 = [P4 zeros(1,N-length(P4))];
   S = mod(P1+P2+P3+P4,4);
   S = S(1:WordCount);
   if sum(S)==0
      fprintf('Found generators at trial %d:\n',i)
      G2 = oct2gen([g1;g2;g3;g4],[1,n,K-1])
      break
   end
end

if (sum(S)~=0) & (comb<MaxComb)
   % Try all generator tap combinations, except when any gi(x)=0
   fprintf('Searching suboptimal generators\n')
   mask = 2^K-1;
   imin = 2^((n-1)*K);
   j = 0;
   for i=imin:comb-1
      g1o = bitand(bitshift(i,-3*K),mask);
      g2o = bitand(bitshift(i,-2*K),mask);
      g3o = bitand(bitshift(i,-K),mask);
      g4o = bitand(i,mask);
      if (g1o>0) & (g2o>0) & (g3o>0) & (g4o>0)
         j = j+1;
         g1 = de2bi(g1o,K);
         g2 = de2bi(g2o,K);
         g3 = de2bi(g3o,K);
         g4 = de2bi(g4o,K);
         a12 = gfconv(g1,g2);
         a13 = gfconv(g1,g3);
         a23 = gfconv(g2,g3);
         a1 = gfconv(a23,g4);
         a2 = gfconv(a13,g4);
         a3 = gfconv(a12,g4);
         a4 = gfconv(a12,g3);
         P1 = gfconv(a1,r2(1,:));
         P1 = [P1 zeros(1,N-length(P1))];
         P2 = gfconv(a2,r2(2,:));
         P2 = [P2 zeros(1,N-length(P2))];
         P3 = gfconv(a3,r2(3,:));
         P3 = [P3 zeros(1,N-length(P3))];




            P4 = gfconv(a4,r2(4,:));
            P4 = [P4 zeros(1,N-length(P4))];
            S = mod(P1+P2+P3+P4,4);
            S = S(1:WordCount);
            if sum(S)==0
               fprintf('Found generators at i=%d (trial %d):\n',i,j)
               G2 = oct2gen([g1;g2;g3;g4],[1,n,K-1])
               break
            end
         end
      end
   end

   if sum(S)~=0
      fprintf('No generators found\n')
   end

end




EstRate3.m:
function [RateEst,CWLenEst,InputLenEst,AlphabetSizeEst] = ...
         EstRate3(FileName,nmin,nmax,lmax)

disp 'Searching for code rate via RREF in GF(2)'
RateEst = 1;
nqmin = nmin;
nqmax = nmax;

for n = nmin:nmax
   WordCount = 2*n;     % should be > n symbols for accurate results
   EncodedBitCount = n*WordCount;
   s = sprintf('%s.fec',FileName);
   CodedFile = fopen(s,'r');
   [r,BitsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
   fclose(CodedFile);
   if(BitsRead ~= EncodedBitCount)
      disp 'Error reading file'
      BitsRead
      return
   end

   r2 = reshape(r,n,WordCount)';
   %[G2,k] = RrefGF2(r2);
   [G2,k] = RrefGF2c(r2);     % MEX C-code implementation
   rate = k/n;

   if (rate<RateEst)
      RateEst = rate;
      CWLenEst = n;
      InputLenEst = k;
      AlphabetSizeEst = 2;
      if(rate<1)




         fprintf('Code rate estimate: %d/%d = %f\n',k,n,RateEst)
      end
   end
end


for BitsPerSym = 2:lmax
   q = 2^BitsPerSym;
   if RateEst<1
      nmin = CWLenEst*log2(AlphabetSizeEst)/BitsPerSym;
      if (abs(nmin - round(nmin)) > 1e-10) | (nmin<7)
         nmin = [];
      else
         fprintf('\nSearching for code rate via RREF in GF(%d)\n',q)
      end
      nmax = nmin;
   else
      fprintf('\nSearching for code rate via RREF in GF(%d)\n',q)
   end

  for n = nmin:nmax
     nq = BitsPerSym*n;
     WordCount = n+10;    % should be > n symbols for accurate results
     EncodedBitCount = nq*WordCount;
     s = sprintf('%s.fec',FileName);
     CodedFile = fopen(s,'r');
     [r,BitsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
     fclose(CodedFile);
     if(BitsRead ~= EncodedBitCount)
        disp 'Error reading file'
        BitsRead
        EncodedBitCount
        return
     end

     EncodedBitCount = EncodedBitCount/BitsPerSym;
     r = reshape(r,BitsPerSym,EncodedBitCount)';
     r = bits2sym(r,BitsPerSym,EncodedBitCount);
     r2 = reshape(r,n,WordCount)';
     [G2,k] = RrefGFxc(r2,q);      % MEX C-code implementation
     rate = k/n;

      if (rate<=RateEst)
         RateEst = rate;
         CWLenEst = n;
         InputLenEst = k;
         AlphabetSizeEst = q;
         if(rate<1)
            fprintf('Code rate estimate: %d/%d = %f\n',k,n,RateEst)
         end
         if(rate<0.97)        % Max BCH rate = 247/255 = .969
            break             % STOP AT FIRST CLEAR SIGN OF CODING?
         end
      end
   end
end




if RateEst==1
   disp 'INPUT IS NOT CODED'
   return
end




FindRoots.m:
function [ExtFieldEst,roots,CWLenEst] = ...
         FindRoots(FileName,WordCount,q,n)

% Look for roots in extension fields assuming base field is nonbinary

BitsPerSym = log2(q);
nmin = 6;
nmax = 255;

EncodedBitCount = nmax*WordCount*BitsPerSym;
s = sprintf('%s.fec',FileName);
CodedFile = fopen(s,'r');
[r,WordsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
if(WordsRead ~= EncodedBitCount)
   disp 'Error reading file'
   WordsRead
end

% Search fields covering all subfields from GF(2) to GF(2^20)
m = [12 20 14 16 18 11 15];
n2 = [];
ExtFields = [];

for mi=1:length(m)
   qm = 2.^m(mi)
   % Form array of valid block lengths for this field
   if (nargin < 4),
      n = SearchLens(qm-1,nmin,nmax)
   end
   n1 = [];
   MaxRoots = 0;
   for ni=1:length(n)
      fprintf('Searching for roots in GF(%d), n = %d\n',qm,n(ni));
      if BitsPerSym > 1
         EncodedBitCount = n(ni)*WordCount*BitsPerSym;
         r2 = reshape(r(1:EncodedBitCount),BitsPerSym,...




                       EncodedBitCount/BitsPerSym)';
        r2 = bits2sym(r2,BitsPerSym,EncodedBitCount/BitsPerSym);
        r2 = reshape(r2,n(ni),WordCount)';
     else
        EncodedBitCount = n(ni)*WordCount;
        r2 = reshape(r(1:EncodedBitCount),n(ni),WordCount)';
     end

     % Check combined spectrum of 3 code words for zeros
     R = CumGFFT2(r2,3,n(ni),q,qm,1);
     roots = find(~R);    % find spectral zeros
     if length(roots) > 0
        % This length has passed the 1st root test
        n1 = [n1 n(ni)];
        % Check for spectral zeros over many code words
        R = CumGFFT2(r2,WordCount,n(ni),q,qm,1);
        roots = find(~R)
        if length(roots) > 0
           % This length has passed the 2nd root test
           n2 = [n2 n(ni)]
           ExtFields = [ExtFields qm];
           break
        end
     end
  end      % for ni=1:length(n)

   if length(n2) > 0
      % there was a winner in this field, so skip the other fields
      break
   end
end         % for mi=1:length(m)


if length(n2) > 0
   % Find smallest base field with roots, and search any subfields
   % until the smallest field containing roots is found
   [EF,EFI] = sort(ExtFields);
   qm = EF(1);

  switch qm               %   search subfields of q^m
     case 4096,           %   m = 12 = 2*2*3
        m = [3 4 6 12];   %   note: GF(2) and GF(4) have no valid lengths
     case 1048576,        %   m = 20 = 2*2*5
        m = [5 10 20];
     case 16384,          % m = 14 = 2*7
        m = [7 14];
     case 65536,          % m = 16 = 2*2*2*2
        m = [8 16];
     case 262144,         % m = 18 = 2*3*3
        m = [9 18];
     case 2048,
        m = 11;
     case 32768,
        m = 15;
     otherwise,
        %return




  end

else
   m = [3:12,14:16,18,20];    % search all fields to cover RS codes
   % IMPORTANT NOTE: FIELDS GF(q^m) FOR WHICH m = 13, 17, AND 19
   % HAVE NO VALID LENGTHS n, AND THEREFORE ARE NOT REQUIRED!
   % (e.g., 8K, 128K, 512K)
end

n2 = [];


for mi=1:length(m)
   qm = 2.^m(mi);
   if rem(qm-1,q-1)<1            % bypass invalid nonbinary subfields
      % Form array of valid block lengths for this field
      if (nargin < 4),
         n = SearchLens(qm-1,nmin,nmax)
      end
      n1 = [];
      MaxRoots = 0;
      for ni=1:length(n)
         fprintf('Searching for roots in GF(%d), n = %d\n',qm,n(ni));
         if BitsPerSym > 1
            EncodedBitCount = n(ni)*WordCount*BitsPerSym;
            r2 = reshape(r(1:EncodedBitCount),BitsPerSym,...
                           EncodedBitCount/BitsPerSym)';
            r2 = bits2sym(r2,BitsPerSym,EncodedBitCount/BitsPerSym);
            r2 = reshape(r2,n(ni),WordCount)';
         else
            EncodedBitCount = n(ni)*WordCount;
            r2 = reshape(r(1:EncodedBitCount),n(ni),WordCount)';
         end
         % Check combined spectrum of 3 code words for zeros
         R = CumGFFT2(r2,3,n(ni),q,qm,1);
         roots = find(~R);    % find spectral zeros
         if length(roots) > 0
            % This length has passed the 1st root test
            n1 = [n1 n(ni)];
            % Check for spectral zeros over many code words
            R = CumGFFT2(r2,WordCount,n(ni),q,qm,1)
            roots = find(~R)
            if length(roots) > 0
               % This length has passed the 2nd root test
               n2 = n(ni)
               ExtFields = qm;
               break
            end
         end
      end      % for ni=1:length(n)

     if length(n2) > 0
        % There was a winner in this field, so skip the other fields
        break
     end
  end      % if rem(qm1,q-1)<1




end        % for mi=1:length(m)

fclose(CodedFile);
CWLenEst = n2;
ExtFieldEst = ExtFields;

if length(n2) < 1
   disp 'NOT A CYCLIC CODE'
end

GFFT2.m:
function [X] = GFFT2(x,WordCount,n,q,qm,mx)

% Galois Field Fourier Transform:
% Time-domain vector x is over GF(q), elements are q-ary
% Frequency-domain vector X is over GF(q^m), elements are q^m-ary

[vectors,symbols] = SelField(qm,mx);
X = zeros(WordCount,n);
a = zeros(1,n);
qm1 = qm-1;
% Reverse order in time sequence to form polynomial
x = fliplr(x);

if 1
   % C code implementation
   X = gfft2c(x,vectors,symbols,q,qm);
else
   % Convert symbols {0,1,2=alpha,...} to
   % powers {-inf=0,0=1,1=alpha,...}
   x2 = sym2powerGFx(x);
   K1 = qm1/n;
   K2 = qm1/(q-1);

  for l=1:WordCount
     for j=0:(n-1)        % frequency index
        for i=0:(n-1)     % time index
           % Convert GFFT coefficients from powers of gamma to alpha:
           % Calculate gamma as an nth root of unity in GF(q^m)
           ij = rem(i*j,n);
           % Calculate alpha as an (q^m-1) root of unity in GF(q^m)
           ij = rem(ij*K1,qm1);

           % Convert input coefficients from powers of beta to alpha:
           % Calculate beta as an (q-1) root of unity in GF(q)
           k = x2(l,i+1);
           if k >= 0      % only add if input is nonzero (power > -inf)
              % Calculate alpha as an (q^m-1) root of unity in GF(q^m)
              k = rem(k*K2,qm1);
              ai = rem(ij+k,qm1);
              a(i+1) = vectors(ai+2);
           else
              a(i+1) = 0;
           end




         end
         Xij = SumGFx(a);
         X(l,j+1) = symbols(Xij+1);
      end
   end
end



CumGFFT2.m:
function [Xcum] = CumGFFT2(x,WordCount,n,q,qm,mx)

% Cumulative Galois Field Fourier Transform:
% "OR" all frequency words together to isolate spectral zeros (roots).

X = GFFT2(x,WordCount,n,q,qm,mx);
Xcum = zeros(1,n);

for i=1:WordCount
   Xcum = bitor(Xcum,X(i,:));
end




SumGFx.m:
function [z] = SumGFx(x)

% Sum the elements of vector x using GF(q) vector addition
z = x(1);
for i=2:length(x)
   z = bitxor(z,x(i));
end




SearchLens.m:
function [n] = SearchLens(qm1,nmin,nmax)

r   =   rem(qm1,[1:nmax]);
n   =   find(~r);
i   =   find(n>nmin);
n   =   n(i);




EstMinDist.m:
function [dmin] = EstMinDist(FileName,n,q,WordCount)

% Estimate minimum distance between code words

% Read bit stream and segment a block into a fixed # of code words
EncodedBitCount = n*WordCount;
s = sprintf('%s.fec',FileName);
CodedFile = fopen(s,'r');
[r,BitsRead] = fread(CodedFile,EncodedBitCount,'ubit1');
if(BitsRead ~= EncodedBitCount)
   disp 'Error reading file'
   BitsRead
end
r = reshape(r,n,WordCount)';

% Bitwise XOR and sum to find distance between each pair
d = inf*ones(WordCount);
for i=1:WordCount
   for j=(i+1):WordCount
      d(i,j) = sum(rem(r(i,:)+r(j,:),q));
      if d(i,j)<1
         d(i,j) = inf;     % ignore zero distances
      end
   end
end

dmin = min(min(d));




EstRedundancy.m:
function redundancy = EstRedundancy(n,q,t)

Vq = 0;
for i=0:t
   Vq = Vq + choose(n,i)*(q-1)^i;
end
redundancy = log2(Vq)/log2(q);      % logq(Vq(n,t))




choose.m:
function [nck] = choose(n,k)

% n choose k, i.e., n!/(k!(n-k)!)
nck = (prod((n-k+1):n)./prod(1:k));




FindConsecRoots.m:
function [ConsecRoots,t] = FindConsecRoots(BaseRoots)

if length(BaseRoots)<2
   ConsecRoots = -1;
   t = -1;
   return
end

derivative = diff(BaseRoots);         % first derivative
CRI = find(derivative==1);
ConsecRoots = BaseRoots(CRI);
DiffCount = 1;

% Take higher derivatives to separate clusters of consecutve roots
% and find the largest group
while length(CRI)>1
   DiffCount = DiffCount+1;
   if DiffCount>20
      disp 'Error: too many derivatives!'
      dbcont
   end
   derivative = diff(ConsecRoots);
   CRI = find(derivative==1);
   ConsecRoots = ConsecRoots(CRI);
end

ConsecRoots = [ConsecRoots:ConsecRoots+DiffCount];
t = length(ConsecRoots)/2;




PolyGFx.m:
function [v] = PolyGFx(roots,n,q,qm,mx)

% Build polynomial from Galois Field roots

[vectors,symbols] = SelField(qm,mx);
vectors = de2bi(vectors);     % gfconv requires vector array
qm1 = qm-1;
L = length(roots);
v1 = [0 roots(1)];

for l=2:L
   v2 = [0 roots(l)];
   v1 = gfconv(v1,v2,vectors);
end

% Convert coefficients back to GF(q)
v1 = v1*(q-1)/qm1;
% Convert powers {-inf=0,0=1,1=alpha,...} to symbols {0,1,2=alpha,...}
j = find(v1<0);
v = v1+1;
v(j) = 0;




ReadFields.m:
global   vectors8_m1;
global   symbols8_m1;
global   vectors8_m2;
global   symbols8_m2;
global   vectors16_m1;
global   symbols16_m1;
global   vectors32_m1;
global   symbols32_m1;
global   vectors64_m1;
global   symbols64_m1;
global   vectors128_m1;
global   symbols128_m1;
global   vectors256_m1;
global   symbols256_m1;
global   vectors512_m1;
global   symbols512_m1;
global   vectors1K_m1;




global   symbols1K_m1;
global   vectors2K_m1;
global   symbols2K_m1;
global   vectors4K_m1;
global   symbols4K_m1;
global   vectors16K_m1;
global   symbols16K_m1;
global   vectors32K_m1;
global   symbols32K_m1;
global   vectors64K_m1;
global   symbols64K_m1;
global   vectors256K_m1;
global   symbols256K_m1;
global   vectors1M_m1;
global   symbols1M_m1;

% GF8 symbol to vector mapping and reverse mapping:
% {0 1 alpha alpha^2 ... alpha^6} <---> symbols = {0 1 2 3 ... 7}
%                                   <---> powers = {-inf 0 1 2 ... 6}
% and GF8 is defined by the minimal polynomial selected by mx:
%     mx=1: M(x) = 1 + x + x^3 --> alpha^3 = alpha + 1
%     mx=2: M(x) = 1 + x^2 + x^3 --> alpha^3 = alpha^2 + 1
% 3-bit vectors represent: {alpha^2 alpha 1}
% e.g., alpha^3 = 011 = 3 (mx=1), alpha^3 = 101 = 5 (mx=2)
[vectors8_m1,symbols8_m1] = ReadGFx(8,3);
[vectors8_m2,symbols8_m2] = ReadGFx(8,5);
[vectors16_m1,symbols16_m1] = ReadGFx(16,3);
[vectors32_m1,symbols32_m1] = ReadGFx(32,5);
[vectors64_m1,symbols64_m1] = ReadGFx(64,3);
[vectors128_m1,symbols128_m1] = ReadGFx(128,9);
[vectors256_m1,symbols256_m1] = ReadGFx(256,29);
[vectors512_m1,symbols512_m1] = ReadGFx(512,17);
[vectors1K_m1,symbols1K_m1] = ReadGFx(1024,9);
[vectors2K_m1,symbols2K_m1] = ReadGFx(2048,5);
[vectors4K_m1,symbols4K_m1] = ReadGFx(4096,83);
[vectors16K_m1,symbols16K_m1] = ReadGFx(16384,43);
[vectors32K_m1,symbols32K_m1] = ReadGFx(32768,3);
[vectors64K_m1,symbols64K_m1] = ReadGFx(65536,45);
[vectors256K_m1,symbols256K_m1] = ReadGFx(262144,39);
[vectors1M_m1,symbols1M_m1] = ReadGFx(1048576,83);

% IMPORTANT NOTE: FIELDS GF(q^m) FOR WHICH m = 13, 17, AND 19 HAVE NO
% VALID LENGTHS n, AND THEREFORE ARE NOT REQUIRED!




ReadGFx.m:
function [vectors,symbols] = ReadGFx(qm,mx)

% Read a Galois Field GF(q^m) based on a minimal polynomial m(x).
% Note that mx is provided as a binary number, not an array;
% also, mx is provided as the actual polynomial minus the x^(q^m) term,
% since alpha^(q^m) = mx,        m(x) = mx + x^(q^m)

size = sprintf('ubit%d',log2(qm));
s = sprintf('gf%d_%d.vec',qm,mx);
fid = fopen(s,'r');
vectors = fread(fid,qm,size);
fclose(fid);

s = sprintf('gf%d_%d.sym',qm,mx);
fid = fopen(s,'r');
symbols = fread(fid,qm,size);
fclose(fid);




SelField.m:
function [vectors,symbols] = SelField(qm,mx)

global   vectors8_m1;
global   symbols8_m1;
global   vectors8_m2;
global   symbols8_m2;
global   vectors16_m1;
global   symbols16_m1;
global   vectors32_m1;
global   symbols32_m1;
global   vectors64_m1;
global   symbols64_m1;
global   vectors128_m1;
global   symbols128_m1;
global   vectors256_m1;
global   symbols256_m1;
global   vectors512_m1;
global   symbols512_m1;
global   vectors1K_m1;
global   symbols1K_m1;
global   vectors2K_m1;
global   symbols2K_m1;
global   vectors2K_m2;




global   symbols2K_m2;
global   vectors4K_m1;
global   symbols4K_m1;
global   vectors16K_m1;
global   symbols16K_m1;
global   vectors32K_m1;
global   symbols32K_m1;
global   vectors64K_m1;
global   symbols64K_m1;
global   vectors256K_m1;
global   symbols256K_m1;
global   vectors1M_m1;
global   symbols1M_m1;


switch qm
   case 2,
      vectors = [0 1];
      symbols = [0 1];
   case 4,
      vectors = [0 1 2 3];
      symbols = [0 1 2 3];
   case 8,
      if mx==1
         vectors = vectors8_m1;
         symbols = symbols8_m1;
      else
         vectors = vectors8_m2;
         symbols = symbols8_m2;
      end
   case 16,
      vectors = vectors16_m1;
      symbols = symbols16_m1;
   case 32,
      vectors = vectors32_m1;
      symbols = symbols32_m1;
   case 64,
      vectors = vectors64_m1;
      symbols = symbols64_m1;
   case 128,
      vectors = vectors128_m1;
      symbols = symbols128_m1;
   case 256,
      vectors = vectors256_m1;
      symbols = symbols256_m1;
   case 512,
      vectors = vectors512_m1;
      symbols = symbols512_m1;
   case 1024,
      vectors = vectors1K_m1;
      symbols = symbols1K_m1;
   case 2048,
      if mx==1
         vectors = vectors2K_m1;
         symbols = symbols2K_m1;
      else




         vectors = vectors2K_m2;
         symbols = symbols2K_m2;
      end
   case 4096,
      vectors = vectors4K_m1;
      symbols = symbols4K_m1;
   case 16384,
      vectors = vectors16K_m1;
      symbols = symbols16K_m1;
   case 32768,
      vectors = vectors32K_m1;
      symbols = symbols32K_m1;
   case 65536,
      vectors = vectors64K_m1;
      symbols = symbols64K_m1;
   case 262144,
      vectors = vectors256K_m1;
      symbols = symbols256K_m1;
   case 1048576,
      vectors = vectors1M_m1;
      symbols = symbols1M_m1;
   otherwise,
      disp 'Invalid Galois Field'
      % IMPORTANT NOTE: FIELDS GF(q^m) FOR WHICH m = 13, 17, AND 19
      % HAVE NO VALID LENGTHS n, AND THEREFORE ARE NOT REQUIRED!
      % (e.g., 8K, 128K, 512K)
end




power2symGFx.m:
function [y] = power2symGFx(x)

% Convert powers {-inf=0,0=1,1=alpha,2=alpha^2,...}
% to symbols {0,1,2=alpha,3=alpha^2,...}
y = log2(2.^(x+1) + (x<0));




sym2powerGFx.m:
function [y] = sym2powerGFx(x)

% Convert symbols {0,1,2=alpha,3=alpha^2,...}
% to powers {-inf=0,0=1,1=alpha,2=alpha^2,...}




y = log2(~~x) + x-1;

sym2bits.m:
function [bits] = sym2bits(symbols)

[r,c] = size(symbols)
if c>1
   b = de2bi(symbols);
   [r2,c2] = size(b);
   bits = [];
   for i=1:c
      x = de2bi(symbols(:,i),c2);
      bits = [bits x];
   end
else
   bits = de2bi(symbols);
end




bits2sym.m:
function [symbols] = bits2sym(s,n,WordCount)

symbols = bi2de(fliplr(s));
                                           APPENDIX B:
                                           C Source Code



GFFT2.c:

/*
% function [X] = GFFT2(x,WordCount,n,qm,mx)
%     Galois Field Fourier Transform:
%     Time-domain vector x is over GF(q), elements are q-ary
%     Frequency-domain vector X is over GF(q^m), elements are q^m-ary
%     For BCH: n = (q^m-1)
%     For RS: n = q-1, (m=1), hence x and X are both in GF(q)
*/

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#ifdef MATLAB_MEX_FILE
#include "mex.h"
#endif

#define LOG_SESSION           0

void calcGFFT();
#if LOG_SESSION
void printMatrix(int *A);
FILE *logFile;
#endif


#ifdef MATLAB_MEX_FILE
double *pAin;          // double precision input matrix from Matlab workspace
double *pVector;       // GF(q^m) vectors input from Matlab workspace
double *pSymbol;       // GF(q^m) symbols input from Matlab workspace
double *pAout;         // double precision reduced output matrix to Matlab workspace
int *x;                // input matrix, represented as a vector of binary numbers
int *vectors,*pVectors;         // GF(q^m) vectors
int *symbols,*pSymbols;         // GF(q^m) symbols
#else
// DEBUG C CODE
int x[7] = {1,1,0,0,1,0,0};

                                                  121




int vectors[8] = {0,1,2,4,3,6,7,5};
int symbols[8] = {0,1,2,4,3,7,5,6};
#endif

int *X;                // input matrix, represented as a vector of binary numbers
int m,n;               // number of rows, columns of x
int q,qm;              // alphabet size q, Galois field q^m
int *px,*pX;           // input/output matrix pointer




#ifdef MATLAB_MEX_FILE

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    int i=0,j=0,k;

    if (nrhs < 5)
    {
         mexErrMsgTxt("Not enough input arguments!");
         return;
    }

     m = mxGetM(prhs[0]);
     n = mxGetN(prhs[0]);
     q = (int)mxGetScalar(prhs[3]);
     qm = (int)mxGetScalar(prhs[4]);
#if LOG_SESSION
     printf("x[%d,%d]:\n",m,n);
#endif

    x = calloc(m*n,sizeof(int));
    if(x==NULL)
    {
         printf("x alloc failed\n");
         return;
    }
    px = x;
    X = calloc(m*n,sizeof(int));
    if(X==NULL)
    {
         printf("X alloc failed\n");
         return;
    }
    pX = X;
    vectors = calloc(qm,sizeof(int));
    if(vectors==NULL)
    {
         printf("vectors alloc failed\n");




     return;
}
symbols = calloc(qm,sizeof(int));
if(symbols==NULL)
{
     printf("symbols alloc failed\n");
     return;
}

// Read input matrix from Matlab workspace; store columns
// such that code words are sequential
for(i=0; i<m; i++)
{
     pAin = mxGetPr(prhs[0]) + i;
     for(j=0; j<n; j++)
     {
          // Convert symbols {0,1,2=alpha,...} to powers {-inf=0,0=1,1=alpha,...}
          // by subtracting 1 (-1 represents 0 = alpha^-inf)
          *px++ = (int)*pAin - 1;
          pAin += m;
     }
}
// Read Galois field vectors and symbols from Matlab workspace
pVector = mxGetPr(prhs[1]);
pVectors = vectors;
for(i=0; i<qm; i++)
{
     *pVectors++ = (int)*pVector++;
}
pSymbol = mxGetPr(prhs[2]);
pSymbols = symbols;
for(i=0; i<qm; i++)
{
     *pSymbols++ = (int)*pSymbol++;
}

// Take GFFT of each row of input matrix
calcGFFT();

plhs[0] = mxCreateDoubleMatrix(m,n,mxREAL);
pX = X;
for(i=0; i<m; i++)
{
     pAout = mxGetPr(plhs[0]) + i;
     for(j=n-1; j>=0; j--)
     {
          *pAout = (double)*pX++;
          pAout += m;
     }
}




    return;
}

#endif




void main()
{
    int i;
    int *x2;

    // DEBUG: SET INPUTS
    m = 1;        // rows
    n = 7;        // columns
    q = 2;
    qm = 8;
    x2 = calloc(m*n,sizeof(int));
    if(x2==NULL)
    {
         printf("x2 alloc failed\n");
         return;
    }
    for(i=0; i<n; i++)
    {
         x2[i] = x[n-i-1]-1;          // convert to powers of alpha
    }
    for(i=0; i<n; i++)
    {
         x[i] = x2[i];
    }

    X = calloc(m*n,sizeof(int));
    if(X==NULL)
    {
        printf("X alloc failed\n");
        return;
    }
    pX = X;

    calcGFFT();
}


void calcGFFT()
{
    int K1,K2,qm1;
    int i,j,k,l,ij;




    int xij,Xij;

#if LOG_SESSION
     logFile = fopen("Gfft2.log","w");
     if(logFile==NULL)
     {
          printf("Error opening log file\n");
     }
     fprintf(logFile,"q = %d, q^m = %d\n",q,qm);
     printMatrix(x);
     fprintf(logFile,"\n\n");
#endif

    qm1 = qm-1;
    K1 = (int)(qm1/n);
    K2 = (int)(qm1/(q-1));
    pX = X;

    for(l=0; l<m; l++)
    {
         for(j=0; j<n; j++)        // frequency index
         {
              Xij = 0;
              px = x + n*l;
              for(i=0; i<n; i++)   // time index
              {
                   // Convert GFFT coefficients from powers of gamma to alpha:
                   // power of gamma, where gamma is an nth root of unity in GF(q^m)
                   ij = (i*j)%n;
                   // power of alpha, where alpha is an (q^m-1) root of unity in GF(q^m)
                   ij = (ij*K1)%qm1;

                   // Convert input coefficients from powers of beta to alpha:
                   // power of beta, where beta is an (q-1) root of unity in GF(q)
                   k = *px++;
                   if(k >= 0) // only add if input is nonzero (power > -inf)
                   {
                        // power of alpha, where alpha is an (q^m-1) root of unity in GF(q^m)
                        k = (k*K2)%qm1;
                        xij = (ij+k)%qm1;
                        Xij ^= vectors[xij+1];      // XOR is GF(qm) addition
                   }
              }
              *pX++ = symbols[Xij];

#if LOG_SESSION
           fprintf(logFile,"X[%d] = %d\n",j,symbols[Xij]);
           printMatrix(X);
#endif
       }




    }

#if LOG_SESSION
     // Print out results
     fprintf(logFile,"\n------------\n");
     printMatrix(m);
     fprintf(logFile,"Loop count = %d\n",loopCount);
     fclose(logFile);
#endif
}



#if LOG_SESSION

void printMatrix(int *A)
{
    int i,j,k;
    int maxColumn;
    int *pA;

    if(m>10)
    {
         return;
    }
    fprintf(logFile,"A[%d,%d]:\n",m,n);

    pA = A;
    for(i=0; i<m; i++)
    {
         fprintf(logFile,"%2d: ",i);
         for(j=0; j<n; j++)
         {
              fprintf(logFile,"%d ",*pA++);
         }
         fprintf(logFile,"\n");
    }
    fprintf(logFile,"\n");
}

#endif




RrefGF2.c:

/*
% function [G,rank] = RrefGF2(A)
% Returns reduced row echelon form of A and rank of A;
% matrix reduction is done in GF(2) algebra.
*/

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#ifdef MATLAB_MEX_FILE
#include "mex.h"
#endif

#define LOG_SESSION            0

void reduceMatrix();
#if LOG_SESSION
void printMatrix(int rows);
FILE *logFile;
#endif

#ifdef MATLAB_MEX_FILE
double *pAin;        // double precision input matrix from Matlab workspace
double *pAout;       // double precision reduced output matrix to Matlab workspace
double *pRank;       // double precision rank
unsigned long *A; // input matrix, represented as a vector of binary numbers
#else
unsigned int A[10] = {0xFF,0x7F,0x3F,0x1F,0xF,0x7,0x3,0x1};
#endif

int m,n;              // number of rows, columns of A
int nw;               // number of parallel words concatenated to form all columns of A
int *jb;
int rank;
unsigned long *pA1;   // input matrix pointer
unsigned long *pA2;   // input matrix pointer



#ifdef MATLAB_MEX_FILE

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    int i=0,j=0,k;
    unsigned int bit,word;
    int maxColumn;




    if (nrhs != 1)
    {
         mexErrMsgTxt("Not enough input arguments!");
         return;
    }

     m = mxGetM(prhs[0]);
     n = mxGetN(prhs[0]);
     nw = (int)ceil((double)n/(double)32);
#if LOG_SESSION
     printf("A[%d,%d]:\n",m,n);
     printf("nw = %d\n",nw);
#endif

    A = calloc(m*nw,sizeof(unsigned long));
    if(A==NULL)
    {
        printf("Alloc failed\n");
        return;
    }
    pA1 = A;

    // Read input matrix from Matlab workspace and convert to binary arrays.
    if(n<=32)
    {
         for(i=0; i<m; i++)
         {
              pAin = mxGetPr(prhs[0]) + i;
              word = 0;
              for(j=0; j<n; j++)
              {
                   bit = (int)floor(*pAin + 0.5);
                   pAin += m;
                   if(bit!=0 && bit!=1)
                   {
                        printf("A[%d,%d] = %f\n",i,j,*(pAin-1));
                        mexErrMsgTxt("Nonbinary matrix!");
                        return;
                   }
                   word |= bit<<(n-j-1);
              }
              *pA1++ = (unsigned long)word;
         }
    }

    // Matrices with >32 columns are stored in an m*nw array as follows:
    // A[0]               = [row 1, columns 1-32]
    // A[1]               = [row 1, columns 33-64]
    // A[2:(nw-1)]        =[      etc     ]




//     A[nw]          = [row 2, columns 1-32]
//     A[nw+1]             = [row 2, columns 33-64]
//     A[nw:(2*nw-1)] = [      etc     ]
//     A[2*nw:m*nw] = [        etc     ]

else
{
       for(i=0; i<m; i++)
       {
            pAin = mxGetPr(prhs[0]) + i;
            for(k=0; k<nw; k++)
            {
                 word = 0;
                 if(n < (k+1)*32)
                 {
                      maxColumn = n-k*32;
                 }
                 else
                 {
                      maxColumn = 32;
                 }


               for(j=0; j<maxColumn; j++)
               {
                    bit = (int)floor(*pAin + 0.5);
                    pAin += m;
                    if(bit!=0 && bit!=1)
                    {
                         printf("A[%d,%d] = %f\n",i,j,*(pAin-m));
                         mexErrMsgTxt("Nonbinary matrix!");
                         return;
                    }
                    word |= bit<<(maxColumn-j-1);
               }
               *pA1++ = (unsigned long)word;
           }
       }
}

reduceMatrix();

plhs[0] = mxCreateDoubleMatrix(rank,n,mxREAL);
if(n<=32)
{
     for(i=0; i<rank; i++)
     {
          pAout = mxGetPr(plhs[0]) + i;
          for(j=n-1; j>=0; j--)
          {




                   bit = (A[i]>>j & 0x1);
                   *pAout = (double)bit;
                   pAout += rank;
               }
           }
    }
    else
    {
           pA1 = A;
           for(i=0; i<rank; i++)
           {
                pAout = mxGetPr(plhs[0]) + i;
                for(k=0; k<nw; k++)
                {
                     if(n < (k+1)*32)
                     {
                          maxColumn = n-k*32;
                     }
                     else
                     {
                          maxColumn = 32;
                     }

                   for(j=maxColumn-1; j>=0; j--)
                   {
                        bit = (*pA1>>j & 0x1);
                        *pAout = (double)bit;
                        pAout += rank;
                   }
                   pA1++;
               }
           }
    }
    pRank = mxGetPr(plhs[1] = mxCreateDoubleMatrix(1,1,mxREAL));
    *pRank = (double)rank;
    return;
}

#endif



void main()
{
    // DEBUG: SET INPUTS
    m = 8;      // rows; length of array
    n = 8;   // columns; width of each word in bits

    reduceMatrix();
}




void reduceMatrix()
{
    int i=0,j=0,k,l;
    unsigned int columnMask,temp;
    int leadingOneFound=0;
    int loopCount=0;
    int j32 = 0;
    int jnw = 0;

    rank = 0;
    jb = calloc(n,sizeof(int));
    if(jb==NULL)
    {
         printf("Alloc failed\n");
    }

#if LOG_SESSION
     logFile = fopen("RrefGF2.log","w");
     if(logFile==NULL)
     {
          printf("Error opening log file\n");
     }
     fprintf(logFile,"A[%d,%d]:\n",m,n);
     printMatrix(m);
     fprintf(logFile,"\n\n");
#endif

     // Loop over the entire matrix.
     i = 0;
     j = 0;
     if(n<=32)
     {
          while((i < m) & (j < n))
          {
#if LOG_SESSION
              fprintf(logFile,"row %d, column %d\n",i,j);
#endif
              // Find index of largest element in the remainder of column j (i.e., leading one)
              // [p,k] = max(abs(A(i:m,j)));
              leadingOneFound = 0;
              columnMask = 0x1 << (n-j-1);
              for(k=i; k<m; k++)
              {
                   if(A[k] & columnMask)
                   {
#if LOG_SESSION
                        fprintf(logFile,"Pivot row k = %d\n",k);




#endif
                        leadingOneFound = 1;
                        break;
                 }
                 loopCount++;     // DEBUG
           }
           if(leadingOneFound)
           {
                // Remember column index
                // jb = [jb j];
                jb[rank++] = j;
#if LOG_SESSION
                fprintf(logFile,"Rank = %d\n",rank);
                // Swap i-th and k-th rows.
                // A([i k],j:n) = A([k i],j:n);
                fprintf(logFile,"Swap rows k,i (%d,%d)\n",i,k);
#endif
                temp = A[i];
                A[i] = A[k];
                A[k] = temp;

                 // Subtract multiples of the pivot row from all the other rows.
                 // for k = [1:i-1 i+1:m]
                 for(k=0; k<i; k++)
                 {
                      // A(k,j:n) = rem(A(k,j:n) + A(k,j)*A(i,j:n), q);
                      if(A[k] & columnMask)
                      {
                           A[k] ^= A[i];
                      }
                      loopCount++;      // DEBUG
                 }
                 for(k=i+1; k<m; k++)
                 {
                      // A(k,j:n) = rem(A(k,j:n) + A(k,j)*A(i,j:n), q);
                      if(A[k] & columnMask)
                      {
                           A[k] ^= A[i];
                      }
                      loopCount++;      // DEBUG
                 }

                 i++;
            }

#if LOG_SESSION
           printMatrix(m);
#endif
           j++;
       }




    }

    else
    {
           // Matrices with >32 columns are stored in an m*nw array as follows:
           // A[0]               = [row 1, columns 1-32]
           // A[1]               = [row 1, columns 33-64]
           // A[2:(nw-1)]        =[      etc     ]
           // A[nw]              = [row 2, columns 1-32]
           // A[nw+1]            = [row 2, columns 33-64]
           // A[nw:(2*nw-1)] = [         etc     ]
           // A[2*nw:m*nw] = [           etc     ]

       j32 = 0;
       jnw = 0;
       while((i < m) & (j < n))
       {
#if LOG_SESSION
           fprintf(logFile,"row %d, column %d\n",i,j);
#endif
           // Find index of largest element in the remainder of column j.(i.e., leading one)
           // [p,k] = max(abs(A(i:m,j)));
           leadingOneFound = 0;
           if(jnw < nw-1)
           {
                columnMask = 0x1 << (31-j32);
           }
           else
           {
                columnMask = 0x1 << (n-jnw*32-j32-1);
           }




           pA1 = A+i*nw+jnw;
           for(k=i; k<m; k++)
           {
                if(*pA1 & columnMask)
                {
#if LOG_SESSION
                     fprintf(logFile,"Pivot row k = %d\n",k);
#endif
                     leadingOneFound = 1;
                     break;
                }
                pA1 += nw;
                loopCount++;       // DEBUG
           }




           if(leadingOneFound)
           {
                // Remember column index
                // jb = [jb j];
                jb[rank++] = j32+jnw*32;
#if LOG_SESSION
                fprintf(logFile,"Rank = %d\n",rank);
                // Swap i-th and k-th rows.
                // A([i k],j:n) = A([k i],j:n);
                fprintf(logFile,"Swap rows k,i (%d,%d)\n",i,k);
#endif
                pA1 = A+i*nw;
                pA2 = A+k*nw;
                for(l=0; l<nw; l++)
                {
                     temp = *pA1;
                     *pA1++ = *pA2;
                     *pA2++ = temp;
                }

                 // Subtract multiples of the pivot row from all the other rows.
                 // for k = [1:i-1 i+1:m]
                 for(k=0; k<i; k++)
                 {
                      pA2 = A+k*nw;
                      // A(k,j:n) = rem(A(k,j:n) + A(k,j)*A(i,j:n), q);
                      if(*(pA2+jnw) & columnMask)
                      {
                           pA1 = A+i*nw;
                           for(l=0; l<nw; l++)
                           {
                                *(pA2+l) ^= *pA1++;
                                loopCount++;      // DEBUG
                           }
                      }
                 }


                 for(k=i+1; k<m; k++)
                 {
                      pA2 = A+k*nw;
                      // A(k,j:n) = rem(A(k,j:n) + A(k,j)*A(i,j:n), q);
                      if(*(pA2+jnw) & columnMask)
                      {
                           pA1 = A+i*nw;
                           for(l=0; l<nw; l++)
                           {
                                *(pA2+l) ^= *pA1++;
                                loopCount++;     // DEBUG
                           }




                          }
                   }

                   i++;
             }

#if LOG_SESSION
           printMatrix(m);
#endif
           j++;
           j32++;
           if(j32>=32)
           {
                j32 = 0;
                jnw++;
           }
       }
     }


#if LOG_SESSION
     // Print out results
     fprintf(logFile,"\n------------\n");
     printMatrix(rank);
     for(i=0; i<rank; i++)
     {
          fprintf(logFile,"jb[%d] = %d\n",i,jb[i]);
     }
     fprintf(logFile,"\nRank = %d\n\n",rank);
     fprintf(logFile,"Loop count = %d\n",loopCount);
     fclose(logFile);
#endif
}




#if LOG_SESSION

void printMatrix(int rows)
{
    int i,j,k;
    int maxColumn;

    if(rows>10)
    {
         return;
    }




    fprintf(logFile,"A:\n");

    if(n<=32)
    {
         for(i=0; i<rows; i++)
         {
              fprintf(logFile,"%2d: ",i);
              for(j=n-1; j>=0; j--)
              {
                   fprintf(logFile,"%d",A[i]>>j & 0x1);
              }
              fprintf(logFile,"\n");
         }
    }
    else
    {
         pA1 = A;
         for(i=0; i<rows; i++)
         {
              fprintf(logFile,"%2d: ",i);
              for(k=0; k<nw; k++)
              {
                   if(n < (k+1)*32)
                   {
                        maxColumn = n-k*32;
                   }
                   else
                   {
                        maxColumn = 32;
                   }

                  for(j=maxColumn-1; j>=0; j--)
                  {
                       fprintf(logFile,"%d",*pA1>>j & 0x1);
                  }
                  pA1++;
             }
             fprintf(logFile,"\n");
         }
    }
    fprintf(logFile,"\n");
}

#endif

RrefGFx.c:

/*
% function [G,rank] = RrefGFx(A,q)
% Returns reduced row echelon form of A and rank of A;




% matrix reduction is done in GF(q) algebra.
*/

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#ifdef MATLAB_MEX_FILE
#include "mex.h"
#endif

#define LOG_SESSION 0
#define INF         1000

void reduceMatrix();
#if LOG_SESSION
void printMatrix(int rows, int columns);
FILE *logFile;
#endif
FILE *gfxFile;

#ifdef MATLAB_MEX_FILE
double *pAin;        // double precision input matrix from Matlab workspace
double *pAout;       // double precision reduced output matrix to Matlab workspace
double *pRank;       // double precision rank
int **A;             // input matrix, represented as a 2D array of q-ary elements
int **pA;
#else
unsigned int A[10] = {0xFF,0x7F,0x3F,0x1F,0xF,0x7,0x3,0x1};
#endif

int m,n;         // number of rows, columns of A
int *jb;
int rank;
int *pA1;        // input matrix pointer
int *pA2;        // input matrix pointer
unsigned char vectors[256]; // Galois field LUTs
unsigned char symbols[256];
int q;
int prevQ = 0;




#ifdef MATLAB_MEX_FILE

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    int i=0,j=0,k;




int element;
char s[20];

if (nrhs != 2)
{
     mexErrMsgTxt("Not enough input arguments!");
     return;
}

m = mxGetM(prhs[0]);
n = mxGetN(prhs[0]);
q = (int)mxGetScalar(prhs[1]);

A = (int **)calloc(m,sizeof(int *));
if(A==NULL)
{
     printf("Alloc failed (row pointers to A)\n");
     return;
}
pA = A;
for(i=0; i<m; i++)
{
     pA1 = (int *)calloc(n, sizeof(int));
     if(pA1==NULL)
     {
          printf("Alloc failed (A)\n");
          return;
     }
     *pA++ = pA1;
}

// Read input matrix from Matlab workspace and convert to binary arrays.
// Matrices are stored in an m*n array as follows:
// A[0]                = [row 1, columns 1-32]
// A[1]                = [row 1, columns 33-64]
// A[2:(n-1)]           =[     etc     ]
// A[n]                = [row 2, columns 1-32]
// A[n+1]              = [row 2, columns 33-64]
// A[n:(2*n-1)] = [        etc     ]
// A[2*n:m*n]           =[     etc     ]

for(i=0; i<m; i++)
{
     pAin = mxGetPr(prhs[0]) + i;
     for(j=0; j<n; j++)
     {
          // Read elements from matrix and convert from symbols to powers
          element = (int)floor(*pAin - 0.5);
          if(element<0)
          {




            element = -INF;        // approximate -infinity
        }
        pAin += m;
        A[i][j] = element;
    }
}

if(q!=prevQ)
{
     sprintf(s,"gf%d_8x.vec",q);
     gfxFile = fopen(s,"rb");
     if(gfxFile==NULL)
     {
          printf("File open failed (%s)\n",s);
          return;
     }
     fread(vectors,1,q,gfxFile);
     fclose(gfxFile);
     sprintf(s,"gf%d_8x.sym",q);
     gfxFile = fopen(s,"rb");
     if(gfxFile==NULL)
     {
          printf("File open failed (%s)\n",s);
          return;
     }
     else
     {
          printf("Read new tables for q=%d\n",q);
          prevQ = q;
     }
     fread(symbols,1,q,gfxFile);
     fclose(gfxFile);
}

reduceMatrix();

plhs[0] = mxCreateDoubleMatrix(rank,n,mxREAL);
for(i=0; i<rank; i++)
{
     pAout = mxGetPr(plhs[0]) + i;
     for(j=0; j<n; j++)
     {
          if(A[i][j]<0)
          {
               *pAout = (double)0;
          }
          else
          {
               *pAout = (double)(A[i][j]+1);
          }




             pAout += rank;
         }
    }
    pRank = mxGetPr(plhs[1] = mxCreateDoubleMatrix(1,1,mxREAL));
    *pRank = (double)rank;

    pA = A;
    for(i=0; i<m; i++)
    {
         pA1 = *pA++;
         free(pA1);
    }
    free(A);
    return;
}

#endif



void main()
{
    // DEBUG: SET INPUTS
    m = 8; // rows; length of array
    n = 8; // columns; width of each word in bits

    reduceMatrix();
}



void reduceMatrix()
{
    int i=0,j=0,k,l,jj;
    int a,b,c,aa,a1,b1;
    int kmax;
    int temp;
    int maxElement;
    int loopCount=0;

    rank = 0;
    jb = calloc(n,sizeof(int));
    if(jb==NULL)
    {
         printf("Alloc failed (jb)\n");
         return;
    }

#if LOG_SESSION
     logFile = fopen("RrefGFx.log","w");




    if(logFile==NULL)
    {
         printf("Error opening log file\n");
    }
    printMatrix(m,n);
    fprintf(logFile,"\n\n");
#endif

    // Loop over the entire matrix.
    i = 0;
    j = 0;

    // Matrices with >32 columns are stored in an m*nw array as follows:
    // A[0]               = [row 1, columns 1-32]
    // A[1]               = [row 1, columns 33-64]
    // A[2:(nw-1)]        =[       etc     ]
    // A[nw]              = [row 2, columns 1-32]
    // A[nw+1]                 = [row 2, columns 33-64]
    // A[nw:(2*nw-1)] = [          etc     ]
    // A[2*nw:m*nw] = [            etc     ]

     while((i < m) & (j < n))
     {
#if LOG_SESSION
         fprintf(logFile,"row %d, column %d\n",i,j);
#endif
         // Find index of largest element in the remainder of column j.
         // [p,k] = max(abs(A(i:m,j)));
         maxElement = -INF;
         for(k=i; k<m; k++)
         {
              if(A[k][j] > maxElement)
              {
                   maxElement = A[k][j];
                   kmax = k;
              }
              loopCount++;      // DEBUG
         }

         if(maxElement<0)
         {
              // The column is negligible, zero it out
              for(k=i; k<m; k++)
              {
                   A[k][j] = -INF;
              }
         }
         else
         {
              k = kmax;




#if LOG_SESSION
           fprintf(logFile,"Pivot row k = %d\n",k);
#endif

           // Remember column index
           // jb = [jb j];
           jb[rank++] = j;
#if LOG_SESSION
           fprintf(logFile,"Rank = %d\n",rank);

            // Swap i-th and k-th rows.
            // A([i k],j:n) = A([k i],j:n);
            fprintf(logFile,"Swap rows k,i (%d,%d)\n",i,k);
#endif
            for(l=0; l<n; l++)
            {
                 temp = A[i][l];
                 A[i][l] = A[k][l];
                 A[k][l] = temp;
            }

            // Divide the pivot row by the pivot element.
            // A(i,j:n) = A(i,j:n)/A(i,j);
            a = A[i][j];
            if(a < 0)
            {
                 printf("Error: divide by zero\n");
            }
            else
            {
                 for(jj=j; jj<n; jj++)
                 {
                      if(A[i][jj] >= a)
                      {
                            // Subtract powers to divide elements
                            A[i][jj] = (A[i][jj]-a)%(q-1);
                      }
                      else if(A[i][jj] >= 0)
                      {
                            // Subtract powers to divide elements
                            // Note: must wrap negative result into range [0,q-2]
                            A[i][jj] = (A[i][jj]-a+q-1)%(q-1);
                      }
                 }
            }

            // Subtract multiples of the pivot row from all the other rows.
            // for k = [1:i-1 i+1:m]
            for(k=0; k<m; k++)
            {




if(k!=i)
{
     aa = A[k][j];
     if(aa >= 0)
     {
          //A(k,j:n) = A(k,j:n) - A(k,j)*A(i,j:n);
          for(jj=j; jj<n; jj++)
          {
               if(A[i][jj] >= 0)
               {
                     a1 = (aa+A[i][jj])%(q-1);
               }
               else
               {
                     a1 = -INF;
               }

              if(a1 >= 0)
              {
                   if(a1 >= q-1)
                   {
                        printf("Error: invalid symbol (a1)\n");
                        return;
                   }
                   // Note: Matlab version adds 2 due to index starting at 1
                   a = (int)vectors[a1+1];
              }
              else
              {
                   a = 0;
              }

              b1 = A[k][jj];
              if(b1 >= 0)
              {
                   if(b1 >= q-1)
                   {
                        printf("Error: invalid symbol (b1)\n");
                        return;
                   }
                   b = (int)vectors[b1+1];
              }
              else
              {
                   b = 0;
              }

              c = a^b;
              if(c > 0)
              {




                                            if(c >= q)
                                            {
                                                 printf("Error: Symbol index too large\n");
                                                 return;
                                            }
                                            A[k][jj] = (int)symbols[c]-1;
                                     }
                                     else
                                     {
                                            A[k][jj] = -INF;
                                     }
                                }           // for jj=j:n
                           }          // if aa >= 0
                       }        // if(k!=i)
                }          // for k = [1:i-1 i+1:m]

                i++;
         }             // if(maxElementFound)

#if LOG_SESSION
       printMatrix(m,n);
#endif
       j++;
     }      // while((i < m) & (j < n))

    free(jb);

#if LOG_SESSION
     // Print out results
     fprintf(logFile,"\n------------\n");
     printMatrix(rank,n);
     for(i=0; i<rank; i++)
     {
          fprintf(logFile,"jb[%d] = %d\n",i,jb[i]);
     }
     fprintf(logFile,"\nRank = %d\n\n",rank);
     fprintf(logFile,"Loop count = %d\n",loopCount);
     fclose(logFile);
#endif
}




#if LOG_SESSION

void printMatrix(int rows, int columns)
{
    int i,j;




    fprintf(logFile,"A[%d,%d]:\n",rows,columns);
    for(i=0; i<rows; i++)
    {
         fprintf(logFile,"%2d: ",i);
         for(j=0; j<columns; j++)
         {
              fprintf(logFile,"%d\t",A[i][j]);
         }
         fprintf(logFile,"\n");
    }
    fprintf(logFile,"\n");
}

#endif
                               APPENDIX C:
                     Matlab Data Generation Source Code



GenData.m:
% Build encoder
%[n,k,dim,G,H] = Hamming(3)
%[n,k,dim,G,H] = Hamming(4)
%[n,k,M,G] = Golay23(1)          % g = [1 1 0 0 0 1 1 1 0 1 0 1], t=3
%[n,k,M,G] = Golay23(2)          % g = [1 0 1 0 1 1 1 0 0 0 1 1], t=3
%[n,k,M,q,G] = CRC(7,4,2,[1 0 1 1])    % note: also a Hamming & BCH code
%[n,k,M,q,G] = CRC(2047,2035,2,[1 1 0 0 0 0 0 0 0 1 1 1 1]) % CRC-12
%[n,k,M,q,G] = BCH(63,45,3,2,[1 1 1 1 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1])
%[n,k,M,q,G] = BCH(21,15,1,4,[1 0 1 0 1 1 1]);
%[n,k,M,q,G] = BCH(21,12,2,4,[1 1 1 0 1 1 0 0 1 1]);
%[n,k,M,q,G] = BCH(85,73,3,16,[1 4 11 10 2 4 11 15 10 15 8 5 4]);
% Reed-Solomon
%[n,k,M,q,G] = BCH(63,57,3,64,[1 60 49 44 56 11 22]);
%[n,k,M,q,G] = BCH(255,245,5,256,[1 254 72 53 70 129 83 79 111 51 66]);
%[n,k,M,q,G] = ReedMuller(1,4)      % (16,5) binary Reed-Muller, t=3
%[n,k,M,q,G] = ReedMuller(1,5)      % (32,6) binary Reed-Muller, t=7
%G = [1 0 1; 1 1 1];                      % rate 1/2, K=3 conv code
%G = [1 1 0 1;1 1 1 1];                   % rate 1/2, K=4 conv code
%G = [1 0 0 1 1;1 1 1 0 1];               % rate 1/2, K=5 conv code
%G = [1 1 0 1 0 1;1 0 1 1 1 1];           % rate 1/2, K=6 conv code
%G = [1 0 1 1 0 1 1;1 1 1 1 0 0 1];       % rate 1/2, K=7 conv code
%G = [1 1 1 0 0 1 0 1;1 0 0 1 1 1 1 1];   % rate 1/2, K=8 conv code
%G = oct2gen([561;753]);                  % rate 1/2, K=9 conv code
%G = oct2gen([565;543]);                  % rate 1/2, K=9 (suboptimal)
%G = oct2gen([43572;56246])               % rate 1/2, K=14 conv code
%G = [1 0 1; 1 1 1; 1 1 1];               % rate 1/3, K=3 conv code
%G = [1 0 1 1; 1 0 0 1; 1 1 1 1];         % rate 1/3, K=4 (suboptimal)
%G = oct2gen([452;662;756])               % rate 1/3, K=8 conv code
%G = oct2gen([43512;73542;76266])         % rate 1/3, K=14 conv code
%G = [1 0 1; 1 1 1; 1 1 1; 1 1 1];        % rate 1/4, K=3 conv code
%G = oct2gen([564;564;634;714]);          % rate 1/4, K=7 conv code
%G = oct2gen([42226;46372;73256;73276])   % rate 1/4, K=14 conv code
%G = oct2gen([7;1;4; 2;5;7])           % rate 2/3, K=3, M=4 conv code
%G = oct2gen([63;15;46; 32;65;61])     % rate 2/3, K=6, M=10 conv code
% rate 3/4, K=4, M=9 conv code
G = oct2gen([40;14;34;60; 04;64;20;70; 34;00;60;64])

% Generate coded   bit stream
%[m,c,WordCount]   = BlockEnc('',100,1,n,k,q,G,0)    % no file output
%[m,c,WordCount]   = BlockEnc('Hamming3',1000,1000,n,k,q,G,1);
%[m,c,WordCount]   = BlockEnc('Hamming4',1000,100,n,k,q,G,1);
%[m,c,WordCount]   = BlockEnc('Golay23-1',1000,100,n,k,q,G,1);

                                    146




%[m,c,WordCount] = BlockEnc('Golay23-2',1000,100,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('crc7-4-1',1000,1,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('bch63-45-3',1000,10,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('bch21-15-1-4',1000,5,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('bch21-12-2-4',1000,5,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('bch85-73-3-16',1000,5,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('rs63-57-3',100,14,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('rs255-245-5',100,14,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('rm16-5-3',1000,100,n,k,q,G,1);
%[m,c,WordCount] = BlockEnc('rm32-6-7',1000,10,n,k,q,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K3',100000,2,1,3,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K4',100000,2,1,4,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K5',100000,2,1,5,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K6',100000,2,1,6,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K7',100000,2,1,7,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K8',100000,2,1,8,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K9',10000,2,1,9,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K9b',10000,2,1,9,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-2_K14',10000,2,1,14,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-3_K3',10000,3,1,3,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-3_K4b',10000,3,1,4,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-3_K8',10000,3,1,8,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-3_K14',10000,3,1,14,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-4_K3',10000,4,1,3,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-4_K7',10000,4,1,7,G,1);
%[m,c,WordCount] = ConvEnc2('ConvR1-4_K14',10000,4,1,14,G,1);
%[m,c,WordCount] = ConvEnc3('ConvR2-3_K3_M4',10000,3,2,3,G,1);
%[m,c,WordCount] = ConvEnc3('ConvR2-3_K6_M10',10000,3,2,6,G,1);
[m,c,WordCount] = ConvEnc3('ConvR3-4_K4_M9',10000,4,3,4,G,1);




BlockEnc.m:
function [m,c,WordsWritten] = ...
         BlockEnc(FileName,WordCount,BlockCount,n,k,q,G,FileIO)

% Generate Galois Field vector representations for GF(2^3) to GF(2^20)
if ~exist('vectors8_m1')
   ReadFields
end
[vectors,symbols] = SelField(q,1);

WordsWritten = 0;
SourceBitCount = k*WordCount*log2(q);
EncodedBitCount = n*WordCount*log2(q);
m = zeros(WordCount,k);       % input message words
c = zeros(WordCount,n);       % output code words

if FileIO
   s = sprintf('%s.src',FileName)




   SourceFile = fopen(s,'w');
   s = sprintf('%s.fec',FileName)
   CodedFile = fopen(s,'w');
end

% Encode a random bit stream (represented as a binary matrix)
for j=1:BlockCount
   m = floor(q*rand(WordCount,k));
   if q==2
      for i=1:WordCount
         c(i,:) = rem(m(i,:)*G,q);
      end
   else
      % Convert symbols {0,1,2=alpha,...}
      % to powers {-inf=0,0=1,1=alpha,...}
      m2 = log2(~~m) + m-1;
      G2 = log2(~~G) + G-1;
      for l=1:WordCount
         for i=1:n
            a = zeros(1,k);
            for j=1:k
               ij = m2(l,j)+G2(j,i);
               if ij >= 0 % only add if input is nonzero (power > -inf)
                  ij = rem(ij,q-1);
                  a(j) = vectors(ij+2);
               else
                  a(j) = 0;
               end
            end
            cij = SumGFx(a);
            c(l,i) = symbols(cij+1);
         end
      end
   end
   m1 = fliplr(de2bi(m'));
   c1 = fliplr(de2bi(c'));
   d = reshape(m1',1,SourceBitCount);     % source bit stream
   s = reshape(c1',1,EncodedBitCount);    % Tx bit stream
   if FileIO
      fwrite(SourceFile,d,'ubit1');
      WordsWritten = WordsWritten + fwrite(CodedFile,s,'ubit1');
   end
end

if FileIO
   fclose(SourceFile);
   fclose(CodedFile);
else
   WordsWritten = 0;
end



BCH.m:
function [n,k,M,q,G] = BCH(n,k,t,q,g)




% Check that degree of generator polynomial equals the redundancy
if length(g) ~= (n-k+1)
   disp 'Invalid BCH code'
   return
end

M = q^k;       % code dimension (# of code words)
G = zeros(k,n);
for i=1:k
   G(i,:) = [zeros(1,i-1) g zeros(1,k-i)];   % generator matrix
end




Golay23.m:
function [n,k,M,G,H] = Golay23(gen)

%   Binary (23,12,7) Golay code
%   dmin=7, t=3
n   = 23;
k   = 12;
M   = 2^k;       % code dimension (# of code words)

if gen == 1
   % Generator polynomials for general code
   g = [1 1 0 0 0 1 1 1 0 1 0 1];
else
   g = [1 0 1 0 1 1 1 0 0 0 1 1];
end

G = zeros(k,n);
for i=1:k
   G(i,:) = [zeros(1,i-1) g zeros(1,n-k-i+1)];   % generator matrix
end




Hamming.m:
function [n,k,M,G,H] = Hamming(m)

% Hamming code w/ parameters m>=2, t=1




%   Ex: m=3 -> (7,4) code
n   = 2^m-1;
k   = n-m;
M   = 2^k;       % code dimension (# of code words)

% Generator polynomials for systematic code
P = zeros(k,n-k);
Pm = zeros(k,1);
j = 3;
ii = 2;
for i=1:k
   % Bypass all power-of-2 elements, since these
   % represent the systematic part
   if abs(j-2^ii) < 1e-10
      j = j+1;
      ii = ii+1;
   end
   Pm(i) = j;
   j = j+1;
   for l=1:(n-k)
      P(i,l) = rem(floor(Pm(i)/(2^(n-k-l))),2);
   end
end
G = [P eye(k)];            % generator matrix
H = [eye(n-k) P'];         % parity check matrix




GenFields.m:
global   vectors8_m1;
global   symbols8_m1;
global   vectors8_m2;
global   symbols8_m2;
global   vectors16_m1;
global   symbols16_m1;
global   vectors32_m1;
global   symbols32_m1;
global   vectors64_m1;
global   symbols64_m1;
global   vectors128_m1;
global   symbols128_m1;
global   vectors256_m1;
global   symbols256_m1;
global   vectors512_m1;
global   symbols512_m1;
global   vectors1K_m1;
global   symbols1K_m1;
global   vectors2K_m1;
global   symbols2K_m1;
global   vectors4K_m1;




global   symbols4K_m1;
global   vectors16K_m1;
global   symbols16K_m1;
global   vectors32K_m1;
global   symbols32K_m1;
global   vectors64K_m1;
global   symbols64K_m1;
global   vectors256K_m1;
global   symbols256K_m1;
global   vectors1M_m1;
global   symbols1M_m1;

% GF8 symbol to vector mapping and reverse mapping:
% {0 1 alpha alpha^2 ... alpha^6} <---> symbols = {0 1 2 3 ... 7}
%                                   <---> powers = {N/A 0 1 2 ... 6}
% and GF8 is defined by the minimal polynomial selected by mx:
%     mx=1: M(x) = 1 + x + x^3 --> alpha^3 = alpha + 1
%     mx=2: M(x) = 1 + x^2 + x^3 --> alpha^3 = alpha^2 + 1
% 3-bit vectors represent: {alpha^2 alpha 1}
% e.g., alpha^3 = 011 = 3 (mx=1), alpha^3 = 101 = 5 (mx=2)
[vectors8_m1,symbols8_m1] = GenGFx(8,3);
[vectors8_m2,symbols8_m2] = GenGFx(8,5);
[vectors16_m1,symbols16_m1] = GenGFx(16,3);
[vectors32_m1,symbols32_m1] = GenGFx(32,5);
[vectors64_m1,symbols64_m1] = GenGFx(64,3);
[vectors128_m1,symbols128_m1] = GenGFx(128,9);
[vectors256_m1,symbols256_m1] = GenGFx(256,29);
[vectors512_m1,symbols512_m1] = GenGFx(512,17);
[vectors1K_m1,symbols1K_m1] = GenGFx(1024,9);
[vectors2K_m1,symbols2K_m1] = GenGFx(2048,5);
[vectors4K_m1,symbols4K_m1] = GenGFx(4096,83);
[vectors16K_m1,symbols16K_m1] = GenGFx(16384,43);
[vectors32K_m1,symbols32K_m1] = GenGFx(32768,3);
[vectors64K_m1,symbols64K_m1] = GenGFx(65536,45);
[vectors256K_m1,symbols256K_m1] = GenGFx(262144,39);
[vectors1M_m1,symbols1M_m1] = GenGFx(1048576,83);




GenGFx.m:
function [vectors,symbols] = GenGFx(qm,mx)

% Generate a Galois Field GF(q^m) based on a minimal polynomial m(x).
% Note that mx is provided as a binary number, not an array;
% also, mx is provided as the actual polynomial minus the x^(q^m) term,




%   since   alpha^(q^m) = mx,     m(x) = mx + x^(q^m)

vectors = zeros(qm,1);
v = 1;

for i=1:(qm-1)
   vectors(i+1) = v;
   v = v*2;
   if v>(qm-2)
      v = rem(v,qm);
      v = bitxor(v,mx);
   end
end

[y,i] = sort(vectors);
symbols = i-1;
size = sprintf('uint%d',log2(qm));
s = sprintf('gf%d_%d.vec',qm,mx);
fid = fopen(s,'w')
%fprintf(fid,'%d',vectors);
fwrite(fid,vectors,size)
fclose(fid)
s = sprintf('gf%d_%d.sym',qm,mx);
fid = fopen(s,'w')
%fprintf(fid,'%d',symbols);
fwrite(fid,symbols,size)
fclose(fid)




ReedMuller.m:
function [n,k,M,q,G] = ReedMuller(r,m)

q = 2;
if r==1
   % First order Reed-Muller code w/ parameters (1,m)
   n = 2^m;
   k = m+1;
   M = 2^k;       % code dimension (# of code words)
   G = [ones(1,n); flipud(sym2bits([0:n-1]')')];   % generator matrix
else
   disp 'Higher order Reed-Muller codes not implemented'
end

ConvEnc3.m:
function [m,c,WordsWritten] = ...
         ConvEnc3(FileName,WordCount,n,k,K,G,FileIO)

R = k/n;                        % rate
WordsWritten = 0;




SourceBitCount = k*WordCount;
EncodedBitCount = n*(WordCount+K-1);
m = zeros(WordCount,k);       % input message words
c = zeros(n,WordCount+K-1);

if FileIO
   s = sprintf('%s.src',FileName)
   SourceFile = fopen(s,'w');
   s = sprintf('%s.fec',FileName)
   CodedFile = fopen(s,'w');
end

% Encode a random bit stream (represented as a binary matrix)
m = floor(2*rand(WordCount,k));

for i1=1:n
   for i2=1:k
      i3 = n*(i2-1)+i1;
      ci = gfconv(m(:,i2),G(i3,:));
      l = length(ci);
      % Conv function does not output entire sequence
      % if ending in a string of zeros
      c(i1,1:l) = rem(c(i1,1:l) + ci, 2);
   end
end

d = reshape(m',1,SourceBitCount);      % source bit stream
s = reshape(c,1,EncodedBitCount);      % Tx bit stream
if FileIO
   fwrite(SourceFile,d,'ubit1');
   WordsWritten = fwrite(CodedFile,s,'ubit1');
end

if FileIO
   fclose(SourceFile);
   fclose(CodedFile);
else
   WordsWritten = 0;
end
